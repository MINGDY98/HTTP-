웹 서버는 서로 다른 수천 개의 클라이언트들과 동시 통신

이 서버들은 익명의 클라이언트로부터 받는 모든 요청을 처리하는 것뿐만 아니라 서버와 통신하고 있는 클리언트를 추적해야 할 수 있음

11장은 서버가 통신하는 대상을 식별한는 데 사용하는 기술을 알아봄

## 웹 서버가 사용자를 식별하는 상황

웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보 이용 가능

- 현대 웹 사이트의 개인화된 서비스 제공의 욕구
    - 사용자에 특화된 환영 메시지, 페이지
    - 사용자 맞춤 추천
    - 저장된 사용자 정보 (ex 신용카드 정보)
    - 세션 추적 (최근에 본 상품)

식별 기술

- 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
- 클라이언트 IP 주소 추적으로 알아낸 IP 주소로 사용자를 식별
- 사용자 로그인 인증을 통한 사용자 식별
- URL에 식별자를 포함하는 기술인 fat URL
- 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 쿠키

## HTTP 헤더

- 사용자에 대한 정보를 전달하는 가장 일반적인 일곱 가지 HTTP 요청 헤더
<img width="699" alt="image" src="https://user-images.githubusercontent.com/38098157/211197320-21411c69-f916-409c-99b2-d5963eab8ec2.png">


### 클라이언트 IP 주소

- 초기에는 주소가 좀처럼 바뀌지 않고 웹 사용자가 확실한 IP 가진 점으로 사용자 식별에 클라이언트의 IP 주소를 사용함
- 클라이언트의 IP 주소는 HTTP 헤더에 없으나, 웹 서버는 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다.
    
    ```jsx
    status  = getpeername(tcp_connection_socket, ...);
    (유닉스 시스템)
    ```
    

약점

- 여러 사용자가 같은 컴퓨터를 사용할 경우 식별 불가
- ISP(인터넷 서비스 제공자)는 사용자가 로그인 시 IP주소 동적 할당, 로그인 시간마다 다른 주소를 받음
- NAT(Network Address Translation) 방화벽으로 실제 주소 IP를 방화벽 뒤로 숨김
- HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결. 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 봄. (일부 프락시가 원본 IP 주소를 보존하기 위해 확장 헤더인 Client-ip, X-forwarded-For 를 추가하여 이 문제를 해결하나 모든 프락시가 그렇지 않음)

결론 : 현재는 잘 사용하는 방법이 아님

### 사용자 로그인

HTTP는 웹 사이트 로그인이 쉽도록 WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계 존재

브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 보내기에, 웹 서버는 항상 확인 가능

그러나, 사이트마다 매번 로그인해야 하는 상황은, 사용자를 지치게 만든다.

### 뚱뚱한 URL

URL에 각 사용자에게 할당된 식별번호를 붙여 추적, 로그인 정보가 있다면 그것으로 변화시킴.

<단점>

- 공유하지 못함 (개인 정보)
- 서버 부하 가중 (뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야함)
- 세션 간 지속성의 부재
    - 로그아웃 시 정보를 저장하지 않는 이상 정보를 잃음
- 못생긴 URL (사용자에게 혼란 줄 수 있음)

## 쿠키

사용자를 식별하고 세션을 유지하는 방식 중 현재까지 가장 널리 사용하는 방식

- 넷스케이프가 최초로 개발, 현재는 모든 브라우저에서 지원
- 새로운 HTTP 헤더를 정의함
- 쿠키는 캐시와 충돌할 수 있어, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음

### 쿠키의 종류

1. 세션 쿠키
    1. 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키
    2. 브라우저를 닫으면 삭제됨
        - Discard 파라미터가 설정되어있거나, Expries, Max-Age 파라메터가 없으면 세션 쿠키가 됨
2. 지속 쿠키
    1. 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있음
    2. 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사요

### 쿠키의 동작

1. 웹 서버는 사용자가 왔을 때, 쿠키 할당 (이름 = 값 형태의 리스트), Set-Cookie / Set-Cookie2 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달
2. 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호, 추가 사용자 정보를 포함한다.
    1. Cookie id=”34294”; name=”brian totty”; phone=”555-1212”
3. 브라우저는 서버로부터 온 Set-Cookie 혹은 Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장하고, 미래에 같은 사이트를 방문하면 브라우저는 서버가 이사용자에게 할당했던 쿠키를 cookie 요청 헤더에 기술해 전송한다.

*브라우저의 쿠키 정보를 저장할 책임. 이것을 클라이언트 측 상태라고 하고, 공식적인 이름은 ‘HTTP 상태 관리 체계’

각 브라우저는 각기 다른 방식으로 쿠키를 저장한다.

```jsx

구글 크롬 쿠키

: Cookies라는 SQLITE 파일에 쿠키를 저장

- creation_utc : 쿠키가 생성된 시점
- host_key : 쿠키의 도메인
- name : 쿠키의 이름
- value : 쿠키의 값
- path : 쿠키와 관련도 도메인에 있는 경로
- expire_utc : 쿠키의 파기 시점
- secure : SSL 커넥션일 경우에만 이 쿠키를 보낼지
```

브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않음. 보통 각 사이트에 두 개 혹은 세 개의 쿠키만을 보냄.

- 쿠키를 모두 전달하면 성능이 크게 저하됨.
- 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있음. (개인정보 문제)
- 대부분은 서버에 특화된 내용이라 사이트에서는 무의미

브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보 전달

- 많은 웹 사이트는 광고를 관리하는 협력업체와 계약. 지속 쿠키 생성.
- 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 광고사 서버로 전송 (광고 서버가 동일하기에)
- 광고사는 Referer 헤더도 접목해서, 사용자의 웹 사이트 사용 습관에 대한 데이터 구축 가능
    - 최신 브라우저는 개인정보 설정 기능을 통해 협력업체의 쿠키 사용 방식에 제약을 가할 수 있게함)
    

쿠키 Domain 속성

- 서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어 가능

쿠키 Path 속성

- url 경로의 앞부분만 가리키는 Path 속성을 기술해 웹사이트의 일부 경로 페이지에만 쿠키를 전달할 수도 있다.

```jsx
Set-cookie : pref=compact; domain="airtravelbargains.com"; path=/autos/
```

Secure 속성

- HTTP가 SSL 보안 연결을 사용할 때만 쿠키 전송할지 유무

### 쿠키 구성요소

Version 0(넷스케이프) 쿠키 (현재 사용)

외, Domain, Path

Version1(RFC 2965) 쿠키

- Version 0 과 호환, 아직 모든 브라우저나 서버가 완전히 지원하지는 않음
- 추가사항
    - 쿠키마다 그 목적을 설명하는 설명문 존재
    - 파기 주기에 상관없이 브라우저가 닫히면 쿠키를 강제로 삭제할 수 있음
    - Expires 대신 초 단위의 상대 값으로 쿠키의 생명 주기를 결정 가능한 Max-Age
    - Domain, Path 뿐아니라, URL의 포트번호로도 제어 가능
    - 사용자 이름과 추가적인 키워드를 구별하기 위해 Cookie 헤더에 $ 접두어 존재

### 쿠키와 캐싱

- 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야함
    - 이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나, 누군가의 개인 정보가 다른 이에게 노출되는 최악의 상황이 일어날 수 있음
- 캐시를 다루는 기본 원칙 안내

```
캐시되지 말아야 할 문서가 있다면 표시하라
- Cache-Control : no-cache = "Set-Cookie" 
  => Set-Cookie 헤더 제외하고 캐시 가능
- Cache-Control : public 
	=> 캐시 해도 되는 문서에 사용하면 웹의 대역폭을 절약시킴

Set-Cookie 헤더를 캐시 하는 것에 유의하라
- 어떤 캐시는 응답을 저장하기 전 Set-Cookie 헤더를 제거하기에, 문제 발생 가능
	- 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 Set-cookie 헤더 값을 기술해서 이 문제 개선 가능
		Cache-Contro: must-revalidate, max-age=0 으로 재검사 일어나게함

Cookie 헤더를 가지고 있는 요청을 주의하라
- 요청이 cookie 헤더와 함께 오면, 결과 콘텐츠가 애니정보를 담고 있을 수도 있다는 힌트.

```
