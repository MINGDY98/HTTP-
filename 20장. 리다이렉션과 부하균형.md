리다이렉션 기술 : http 메시지의 최종 목적지를 결정하는 네트워크 도구, 기법, 프로토콜

```jsx
웹 콘텐츠는 흔히 여러 장소에 배포됨
- 한 곳에서 실패한 경우 다른 곳을 이용할 수 있으므로 신뢰성 개선
- 클라이언트가 보다 가까운 리소스에 접근할 수 있게 되어 콘텐츠를 더 빨리 받게 되므로 응답시간 줄여줌.
- 리다이렉션 : 최적의 분산된 콘텐츠를 찾는 것을 도와주는 기법의 집합
```

클라이언트에게 서버, 프락시, 캐시, 게이트웨이는 모두 서버의 특성을 갖기에, 많은 리다이렉션 기법이 그들 모두에게 동작한다. → 일반적인 기법 ,그 외 특화된 기법도 있다.

이상적으로, 클라이언트 근처에 프락시 캐시가 있다면 모든 요청은 프락시 캐시로 흘러 들어간다. 자주 찾는 문서를 저장해 클라이언트에게 직접 제공하기에..

## 일반적인 리다이렉션 방법

서버와 프락시 양쪽에서 공통으로 쓰이는 리다이렉션 방법

### HTTP 리다이렉션

- 장점 : 리다이렉트를 하는 서버가 클라이언트의 아이피 주소를 알기에 정보에 근거해 리다이렉트할 곳을 결정할 수 있음.
- 단점 :
    - 어떤 서버로 리다이렉트할지 결정하려면 원 서버는 많은 처리를 해야함.
    - 페이지에 접근할 때마다 두 번의 왕복이 필요하기에 사용자가 기다리는 시간이 길어짐.
    - 리다이렉트 서버 고장 시 사이트도 고장

HTTP 리다이렉션은 이러한 단점 때문에 보통 다른 리다이렉션 기법과 함께 조합해서 사용

### DNS 리다이렉션 (도메인 이름(예: [www.amazon.com](http://www.amazon.com/))을 머신이 읽을 수 있는 IP 주소(예: 192.0.2.44)로 변환)

웹 사이트에 접근하려고 시도할 때마다, 도메인 이름은 반드시 아이피 주소로 분석해야함. 

dns 분석자는 클라이언트의 운영체제일 수도, 클라이언트의 네트워크에 있는 dns 서버이거나 혹은 더 원격에 있는 dns 서버일 수도 있음. 

dns 분석자는 하나의 도메인에 여러 아이피 주소가 결부되는 것을 허용하며, 어떤 아이피 주소를 반환할 것인가에 대한 방법은 다양

**대표적인 기법인 dns 라운드 로빈**

- 웹 서버 팜 전체에 대한 부하의 균형을 유지하기 위해 DNS 호스트명 분석 기능 사용
- 하지만, 서버에 대한 클라이언트의 상대적인 위치나 서버의 스트레스 고려 안함

```jsx
nslookup www.cnn.com
Name: cnn.com
Address: 207.25.71.5 207.25.71.6, 207.25.71.7

nslookup www.cnn.com
Name: cnn.com
Address: 207.25.71.6, 207.25.71.7 207.25.71.5 
```

대부분의 DNS 서버는 주소 목록을 계속 순환 시키고, 목록의 첫 번째 주소를 사용한다.

**한계점**

부하 균형이 완벽하지는 않음

애플리케이션, 운영체제 등에 의해 dns 룩업의 결과가 기억되어 재사용될 수 있다.

- 호스트 하나에 대해 한 번의 dns 룩업을 수행한 뒤, 그 주소를 계속 사용하는 것
    - dns 룩업 비용 줄임 + 같은 클라이언트와의 대화를 선호하는 서버 존재
    
    
**다양한 알고리즘**

부하 균형 알고리즘

- 가장 부하가 적은 웹 서버를 목록의 가장 위로 올림

근접 라우팅 알고리즘

- 근처의 웹 서버로 보냄

결함 마스킹 알고리즘

- dns 서버가 네트워크의 건강 상태를 모니터링하고 장애를 피해 라우팅 함

### 임의 캐스트 어드래싱

- 여러 서버가 같은 IP 주소를 사용한다. 각 서버는 자신이 인접한 백본 라우터(**네트워크의 서로 다른 메시에있는 별도의 시스템을 서로 연결하는 라우터 유형)**를 향하는 라우터라고 광고한다.
- 그 외의 라우터들은 패킷을 지리적으로 가장 가까운 서버로 보낸다. (그들이 패킷을 가장 가까운 라우터로 보낼 것이라 믿으며)
    
    라우터들은 내장된 최단거리 라우팅 기능 사용한다.
    

**한계점**

주소가 충돌할 위험이 있음, 그에 대한 처리를 해줘야함.

### 아이피 맥 포워딩

레이어-2(데이터 링크 계층) 장비의 역할은 들어오는 특정 맥(MAC) 주소의 패킷을 받아서 나가는 특정 맥 주소로 포워딩하는 것

**한계점**

서버나 프락시는 반드시 한 홉 거리에 있어야함

### 아이피 주소 포워딩

레이어4(transport layer) 스위치는 패킷의 TCP/IP 어드레스를 검증하고 **목적지 아이피 주소**의 변경에 따라 라우팅

장점 : 목적지 서버가 한 홉 거리에 있을 필요가 없다. 

- 레이어-3 ent to end (네트워크계층) 인터넷 라우팅이 패킷을 올바른 위치로 보내줌. (NAT 네트워크 주소 변환)

단점 : 서버나 프락시가 클라이언트의 IP 주소를 잃어버릴 수 있

- 클라이언트로부터 들어오는 TCP 커넥션을 받아주는 스위치는 그 커넥션을 관리하고 있음. 스위치는 반드시 그 커넥션을 통해 클라이언트에게 응답을 돌려주어야하기에 목적지 서버나 프락시로부터의 모든 응답은 스위치로 돌아가야함
    
    **응답의 귀환 경로를 제어할 수 있는 방법**
    
    1. 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 바꿈.  → 응답 패킷을 스위치로가게함. 
        1. 한계점 :  인증이나 결제를 위해 필요할 수도 있는 클라이언트 아이피 주소를 웹 서버가 알 수 없게됨
    2. 출발지 아이피 주소가 그 클라이언트 아이피 주소로 계속 남게함. 서버에서 클라이언트로 바로 가는 경로가 존재하지 않게함(스위치를 안거치고)
        1. 장점 : 서버가 클라이언트의 아이피 주소를 얻음
        2. 단점 : 클라이언트와 서버 사이의 네트워크 전체에 통제 필요

## 프락시 리다이렉션 방법

웹브라우저와 같은 클라이언트들이 프락시로 가는 길을 아는 방법

- 클라이언트가 이용하면 유익한 프락시 캐시가 네트워크 있을 수 있다!

### 명시적 브라우저 설정

대부분의 브라우저에는 프락시 서버에 접촉하기 위해 프락시 이름, 아이피 주소, 포트번호를 설정할 수 있는 풀다운 메뉴 존재

- 사용자가 이를 설정하면, 브라우저는 모든 요청에 대해 프락시와 접촉할 수 있음
- 몇몇 서비스 제공자는 미리 설정이 되어있는 브라우저를 다운 받게끔함.

**단점**

- 프락시들을 사용하도록 설정된 브라우저들은 프락시가 응답하지 않더라도 원 서버와 접촉하지 않음. 만약 프락시가 다운되었거나, 브라우저가 잘못 설정되었다면, 사용자는 접속 문제 경험
- 네트워크 아키텍처를 변경 시에 변경사항을 모든 사용자에게 전파하는 것이 어려움. **브라우저 사용자들이 프락시 설정을 알아서 변경해야함**

### 프락시 자동 설정(PAC, Proxy Auto-configuration) 프로토콜

모든 브라우저가 지원

- 브라우저들이 URL별로 접촉해야할 프락시를 지정한 PAC 파일을 찾도록 함

**장점** 

브라우저가 동적으로 자신을 자동 설정해서 올바른 프락시 서버에 접촉할 수 있음
![image](https://user-images.githubusercontent.com/38098157/216060465-86e9f59e-b138-43dd-a80c-1344ef820451.png)

브라우저에게 DNS 주소나, 서브넷, 호스트 명, 요일 등 여러 매개변수에 근거해 프락시를 선택할 수 있도록 요구할 수 있음.  프락시 위치가 변경된 경우에는 PAC 파일이 서버에서 업데이트됨.


### 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol)

최종 사용자가 수동 프락시 설정 가능/ 웹브라우저가 근처의 프락시를 찾아내어 사용할 수 있게 해주는 방법 제공 목적.

**PAC 파일 자동발견**

WPAD는 HTTP 클라이언트가 PAC 파일의 위치를 알아내고 그 파일을 이용해 적절한 프락시 서버의 이름을 알아낼 수 있게해줌. 

WPAD가 직접적으로 프락시 서버의 이름을 알아내지 않는 것은 PAC 파일에 의해 제공되는 추가적인 기능(부하균형, 프락시 서버를 보조하기 위한 장애 시 대체 작동)을 활용할 수 없기 때문.

```jsx
- WPAD를 이용해 PAC 파일 CURL(서버와 통신할 수 있는 커맨드 명령어 툴)을 찾음
- URL에 해당하는 PAC 파일을 가져옴
- 프락시 서버를 알아내기 위해 PAC 파일 실행
- PAC 파일이 반환한 프락시 서버에게 HTTP 요청 보냄
```

**WPAD 알고리즘**

WPAD는 적절한 PAC 파일 CURL을 결정하기 위해 여러 가지 리소스 발견 기법들을 사용

```jsx
DHCP(Dynamic Host Configuration Protocol, 동적 호스트 설정 프로토콜)
SLP(Service Location Protocol, 서비스 위치 프로토콜)
DNS에게 잘 알려진 호스트 명
DNS의 SRV 레코드
TXT 레코드의 DNS 서비스 URL들
```

클라이언트는 가능한 한 가장 구체적인 설정 정보를 찾되, 그러지 못할 경우에는 덜 구체적인 정보라도 취함.

모든 매커니즘을 시도한 후에도 PAC 파일을 찾지 못하면 프락시 서버를 사용하지 않음 

```jsx
어떤 클라이언트가 johns-desktop.development.foo.com이라는 호스트 명을 찾는다고 가정

DHCP
SLP
"QName=wpad.development.foo.com"에 대한 DNS A 룩업 (IP 주소)
"QName=wpad.development.foo.com"에 대한 DNS SRV 룩업 (hostname에 있는 여러 서비스의 하나하나를 lookup (서비스 이름, 프로토콜, 도메인 이름, 포트 등등))
"QName=wpad.development.foo.com"에 대한 DNS TXT 룩업 (임의의 문자열로 구성된 값으로. 소유한 도메인에 TXT레코드를 추가하여 유효한 도메인인지를 판단하는 과정을 거치게 됨)
"QName=wpad.foo.com"에 대한 DNS A 룩업
"QName=wpad.foo.com"에 대한 DNS SRV 룩업
"QName=wpad.foo.com"에 대한 DNS TXT 룩업
```

모든 DNS룩업은 요청 받은 리소스 종류를 가리키는 wpad 접두어가 붙은 QNAME을 가짐

#**DHCP를 이용한 CURL 발견**

DHCP란? Dynamic Host Configuration Protocol . 호스트의 IP주소와 각종 TCP/IP 프로토콜의 기본 설정을 클라이언트에게 자동적으로 제공해주는 프로토콜

WPAD 클라이언트가 질의하는 DHCP 서버는 반드시 CURL을 저장하고 있어야함.

**#DNS A 레코드 룩업**(주어진 도메인의 IP 주소)

알맞은 프락시 서버의 IP 주소들이 WPAD 클라이언트들이 질의할 수 있는 DNS 서버에 반드시 저장되어 있어야함.

WPAD 클라이언트는 A 레코드 룩업을 DNS 서버로 보내 CURL을 얻음. 룩업이 끝나면 적절한 프락시 서버의 IP 주소를 얻음

**#PAC 파일 가져오기**

한 번 후보 CURL이 생성되면, WPAD 클라이언트는 보통 그 CURL로 GET 요청을 만드는데, 이때 자신이 다룰 수 있는 적절한 CFILE(컴퓨터파일) 포맷 정보가 Accept 헤더를 포함해야 함.

```
ex
Accept: application/x-ns-proxy-autoconfig(WinHttp 프록시 서비스가 PAC 파일을 사용하기 위한 설)
```
**#언제 WPAD(웹 프락시 자동발견 프로세스)를 실행하는가**

- 웹 클라이언트가 시작될 때
- 클라이언트 호스트의 아이피 주소가 변경된 네트워킹 스택으로부터 어떤 언급이 있을 때

위 둘 상황 중 하나에는 수행되어야한다.

**추가로** 이전에 다운 받은 PAC 파일이 HTTP의 만료 규칙에 따라 **만료**되었을 때 WPAD 사이클을 실행한다.

매 url마다 검색한다거나, 그런식으로 자주 동작해서는 안됨!

## 캐시 리다이렉션 방법

캐싱 프락시 서버를 위해 사용되는 보다 복잡한 리다이렉션 기법

신뢰성 높고, 고성능, 콘텐츠의 특정 일부를 갖고 있을 것으로 추정되는 것으로 요청보내기까지 고려

### WCCP 리다이렉션(WCCP2)

WCCP(캐시 조직 프로토콜)? 웹 라우터들이 웹 트래픽을 프락시 캐시로 리다이렉트 할 수 있도록 하기 위해 개발된 것.  라우터들과 캐시 사이의 대화를 관리해 라우터가 캐시를 검사하고 특정 종류의 트래픽을 특정 캐시로 보낼 수 있게한다.

#**WCCP 리다이렉션 동작**

- WCCP를 사용할 수 있는 라우터와, 다른 캐시와 의사소통할 수 있는 캐시가 포함된 네트워크가 필요
- 라우터 집합과 그들의 대상이 되는 캐시들이 WCCP 서비스 그룹을 구성한다. 서비스 그룹의 설정은 어떤 트래픽이 어디로 어떻게 보내지는지, 서비스 그룹에서 부하가 캐시들 사이에서 어떻게 분산되어야 하는지 명시한다.

```jsx
1. 사용자가 브라우저에 URL을 입력합니다.
2. URL은 주소 확인을 위해 DNS(Domain Name System)로 전달됩니다.
3. URL은 웹 서버의 IP 주소로 확인됩니다.
4. 클라이언트는 SYN 요청을 통해 서버에 대한 연결을 시작합니다.
5. 활성 라우터에서 WCCP 웹 캐시 서비스는 HTTP 요청(TCP 포트 80)을 가로채고 구성된 로드 분배를 기반으로 요청을 캐시로 리디렉션합니다.
```

- 라우터는 요청 패킷을 캐시의 아이피 주소와 함께 캡슐화하거나 아이피 맥 포워딩해 키시로 보낸다.
- 요청된 콘텐츠가 캐시에 아직 저장되지 않은 경우…
    1. 캐시는 원천 서버에 대한 연결을 설정하고, 자체 IP 주소를 소스로 사용하고, HTTP GET을 전송
    2. 서버는 콘텐츠를 사용하여 캐시에 응답
    3. CE는 캐시에 저장할 수 있는 콘텐츠의 복사본을 디스크에 작성
- 서비스 그룹의 구성원들은 지속적으로 다른 구성원들의 가용성을 확인하기 위해 하트비트 메시지(정상동작하고있음을 알려주는 메시지)를 교환한다. (부하균형)


**WCCP2 메시지들**
![image](https://user-images.githubusercontent.com/38098157/216061153-e51c8ee3-b036-4829-82ce-90ead97e8af6.png)


**#GRE(Generic Router Encapsulation) 패킷 캡슐화**

WCCP를 지원하는 라우터들은 HTTP 패킷을 특정 서버의 IP 주소와 함께 캡슐화함으로써 그 서버로 리다이렉트함. + GRE 임을 나타내는 IP 헤더 proto 필드도 포함하고 있다.

패킷이 캡슐화 되어있기에 클라이언트 아이피 주소를 잃어버리지 않음
