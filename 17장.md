# 17장 내용 협상과 트랜스코딩

## 내용 협상 기법이란?

- 서버에 있는 여러 페이지들 중 특정 상황에 클라이언트에게 어떤 것이 맞는지 판단하는 기법

### 1. 클라이언트 주도 협상

서버가 클라이언트의 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어 클라이언트가 보고 싶은 것을 선택하게 하는 것

- 여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지 전송

단점 

- 각 페이지에 두 번의 요청 필요. 1. 목록 얻기, 2. 선택한 사본 얻기
- 여러 가지 버전의 URL이 요구됨. www.sample.com/english , www.sample.com/korea

### 2. 서버 주도 협상

클라이언트가 자신이 무엇을 선호하는지에 대한 충분한 정보를 서버에게 주어 서버가 결정하게끔 하는 방식

```jsx
Accept : 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.
Accept-Language : 서버가 어떤 언어로 보내도 되는지 알려준다.
Accept-Charset : 서버가 어떤 차셋(어떤 문자열로 인코딩하는지 ex UTF-8)으로 보내도 되는지 알려준다.
Accept-Encoding : 서버가 어떤 인코딩으로 보내도 되는지 알려준다.
```

HTTP는 상태가 없는 프로토콜이기에 매 요청에 클라이언트는 자신의 선호 정보를 보낼 것

Accept-Language 헤더 정보로 English 를 넣으면 서버는 영어 페이지를 보낼 수 있다.

선호도도 나열할 수 있다. 

```jsx
Accept-Language: en;q=0.5 fr;q=0.0, nl;q=1.0, tr;q=0.0
```

장점 : 협상을 위한 커뮤니케이션 대기시간이 줄어든다.

### 아파치의 내용 협상 지원 

https://httpd.apache.org/docs/2.4/content-negotiation.html

콘텐츠 제공자가 여러 버전의 파일들을 아파치 서버의 적절한 디렉터리에 모두 넣음

그리고, 둘 중의 한 가지 방법으로 내용 협상을 동작시킴

- 웹 사이트 디렉터리에서, 웹 사이트의 각 URI를 위한 type-map 파일을 만듬. 그 type-map 파일은 모든 배리언트와 그들 각각에 대응하는 내용 협상 헤더들을 나열
- 아파치가 그 디렉터리에 대해 자동으로 type-map 파일을 생성하도록 하는 multiViews 지시어를 켬(요청한 리소스의 이름에 대응하는 협상 헤더를 추측해서 자동생성)

#Q. type-map 파일이란?

아파치 서버의 서버 설정 파일에 type-map 파일들을 위한 파일 접미사를 명시한 핸들러를 추가

```jsx
AddHandler type-map .var
```

```jsx
type-map 파일의 예

URI : joes-hardware.html

URI : joes-hardware.en.html
Content-type: text/html
Content-language : en

URI : joes-hardware.fr.de.html
Content-type: text/html;charset=iso-8859-2(아스키를 기반으로 한 표준 문자 인코딩인 ISO/IEC 8859의 일부)
Content-language: fr,de (프랑스, 독일)
```

- 아파치의 협상방법
```
1. 서버가 주도하는 협상(일반적인 경우)
더 나은 결과를 얻기 위해 종종 특정 범위의 품질계수를 조작
2. 자연스러운(transparent)내용협상
```

- 아파치의 협상 알고리즘

아파치는 브라우저에게 보낼 최적의 변형을 선택하기 위해 아래 알고리즘 사용

```
1. 먼저, 협상의 각 범위에 대해 해당하는 Accept* 헤더를 검사하고, 각 변형에 품질값을 매긴다. 어떤 범위의 Accept* 헤더가 받아들이기 않는 변형은 후보에서 제외한다. 어떤 변형도 남지 않으면 4단계로 간다.
2. 다음 각 검사는 순서대로 일어나며, 선택되지 않은 variant는 제외된다. 각 검사 후 한 변형만 남으면 이를 최적의 variant로 선택하고 3단계로 간다.

- 1. Accept 헤더의 품질계수와 변형의 media type에 대한 품질값을 곱하여 가장 높은 값을 가진 변형을 선택한다.
- 2. 가장 높은 언어(language) 품질계수를 가진 변형을 선택한다.
- 3. Accept-Language 헤더에 (있다면) 나온 언어의 순서 혹은 LanguagePriority 지시어에 (있다면) 나온 언어의 순서를 가지고 가장 적합한 언어를 가진 변형을 선택한다.
- 4. 가장 높은 (text/html media type의 버전을 나타내는) 'level' media 파라미터를 가진 변형을 선택한다.
- 5. Accept-Charset 헤더를 가지고 가장 적합한 charset media 파라미터를 가진 변형을 찾는다. 헤더가 없다면 ISO-8859-1 문자집합을 가장 선호한다. text/* media type을 가지지만 명시적으로 특정 문자집합과 연결되지않은 변형은 ISO-8859-1로 가정한다.
- 6. ISO-8859-1이 아닌 charset media 파라미터를 가진 변형들을 선택한다. 그런 변형이 없다면, 대신 모든 변형을 선택한다.
- 7. 가장 적합한 인코딩을 가진 변형을 선택한다. user-agent에 적합한 인코딩을 가진 변형이 있다면 그 변형만을 선택한다. 그렇지않고 인코딩된 변형과 인코딩안된 변형이 같이 있다면 인코딩안됨 변형만을 선택한다. 변형이 모두 인코딩되었거나 모두 인코딩안된 경우 모든 변형을 선택한다.
- 8. content length가 가장 적은 변형을 선택한다.
- 9. 남은 것중 첫번재 변형을 선택한다. 이는 type-map 파일의 앞에 나왔거나, 디렉토리에서 변형을 읽은 경우 파일명을 ASCII 코드 순서로 하여 앞에 나오는 것이다

3. 이제 알고리즘이 '최적의' 변형을 선택했다. 이것을 응답으로 보낸다. HTTP 응답 헤더 Vary는 협상의 범위를 나타내게 된다. (브라우저와 캐쉬는 자원을 캐쉬할때 이 정보를 사용할 수 있다.) 끝.
4. 이 단계에 도달했다면 (모두 브라우저가 받지못하기 때문에) 어떤 변형도 선택이 안된 경우다. ("No acceptable representation"를 뜻하는) 상태 406과 내용으로 사용가능한 변형의 목록을 담은 HTML 문서를 응답을 보낸다. 또, HTML Vary 헤더는 변형의 범위를 나타낸다.
```

- 품질계수 조작
완전하고 정확한 정보를 보내지 않는 브라우저에게 더 나은 결과를 보내기 위한 품질계수 변경

case 1) Media Type 과 와일드 카드

```
Accept: text/html, text/plain, image/gif, image/jpeg, */*

->

Accept: text/html, text/plain, image/gif, image/jpeg, */*; q=0.01

```
보통 브라우저는 선호하는 타입을 쓰고 만약 그 타입들이 안되면 다른 것도 괜찮음을 의미하는 표현으로 위와 같이 보냄
이 요청을 좀 더 구체적으로 만들어준다. 열거한 type은 기본 품질값인 q=1.0을 가지게끔, */*는 q=0.01 을 가지게끔

case 2) language 협상의 예외

아파치 2.0에서 언어 협상이 실패한 경우 부드럽게 복구하기 위해 협상 알고리즘에 예외 추가

클라이언트가 서버에 페이지를 요청했을 때, 서버가 브라우저에 보낸 Accept-language에 맞는 페이지를 단 한개만 찾으면 문제가 없으나, 그러지 않을 경우
"No Acceptable Variant", Multiple Choices"를 보냄

그런데, 이 경우에 Accept-language를 무시하고 클라이언트의 요청에 명확히 맞지는 않지만 문서를 보내도록 설정할 수 있음
ex) en-GB만 포함하도록 되어있다면 en 으로 보냄.

**variant**란?
- 자원에는 여러 표현들(media type, 문자집합, 인코딩 등을 가진 바이트)이 있을 수 있는데, 여러 표현이 있다면 자원을 협상가능하다고 하며 각 표현을 variant라고 함


### 3. 투명 협상

서버 주도 협상의 가장 큰 문제는 확장성이 좋지 않다는 것
모든 사용자 에이전트의 경우 모든 기능과 기본 설정을 표현하는 Accept- 헤더는 매우 클 것이며 모든 요청에서 이를 보내는 것은 특히 웹 리소스의 일부만이 여러 변형을 가지고 있기 때문에 매우 비효율적

클라이언트 입장에서 협상하는 중개자 프락시를 둠으로써 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거 (accept 헤더 안보내도됨)

서버는 클라이언트의 요청에 가장 잘 맞는 것이 무엇인지 판별하려면 어떤 요청 헤더를 검사해야 하는지 프락시에게 반드시 말해줄 수 있어야 함. 

```
서버는 사용 가능한 변형 및 해당 속성이 포함된 목록을 사용자 에이전트에 보냅
      {"paper.1" 0.9 {type text/html} {language en}},
      {"paper.2" 0.7 {type text/html} {language fr}},
      {"paper.3" 1.0 {type application/postscript} {language en}}
      
사용자 에이전트는 최상의 변형을 선택하고 검색
```
<img width="586" alt="image" src="https://user-images.githubusercontent.com/38098157/213589306-f00ad351-ff4e-4e47-a334-1c9fa276815b.png">
```




### 캐시가 가미된 내용 협상 동작 과정

![image](https://user-images.githubusercontent.com/38098157/212543795-32347f62-6c28-4326-abde-59c34fb8e20e.png)


처음에는 프랑스어 사용자의 요청을  캐시가 서버에 그대로 전달하고, 응답을 저장

두번째는 스페인어 사용자의 요청을 캐시가 확인하고, 갖고 있는 프랑스어 문서가 해당되는 것이 아니니까 프랑스 문서를 서버에게 그대로 전달하고 그 응답도 저장

이제 캐시는 같은 URL에 대해 두 개의 다른 문서를 갖게 되는데, 이 다른 버전들은 variant 혹은 alternate로 불리기에, 내용 혐상은 variant 중에서 클라이언트의 요청에 가장 잘 맞는 것을 선택하는 과정으로 이해할 수도 있다.



### 다른 헤더에 기초된 내용 협상

서버가 콘텐츠를 판단하는 기준이 User-Agent 같은 Accept 가 아닌 다른 헤더라면, 캐시는 반드시 그 헤더가 무엇인지 알아야 한다.

HTTP Vary 응답 헤더를 사용해 명시한다.

```jsx
Vary: User-Agent, Cookie
```

새 요청이 도착해서 캐시가 내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾을 때, 캐시는 반드시 응답 안에 서버가 보낸 Vary 헤더가 들어있는지 확인한다.

존재한다면, Vary 헤더가 명시하고 있는 헤더들도 내용 협상에 사용해야한다.

![image](https://user-images.githubusercontent.com/38098157/212543820-907cb0fb-763f-438a-a939-698c9c986c52.png)

## 트랜스코딩

만약, 서버가 클라이언트의 요구에 맞는 문서를 갖고 있지 있다면?

이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수 있는데, 이 옵션을 트랜스코딩이라고 함.

### 포맷 변환

데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것

포맷변환은 내용 협상 헤더에 의해 주도됨 

```jsx
ex) 접속 속도가 느리고 고해상도 이미지에 별로 관심이 없는 클라이언트에서 
이미지가 많은 페이지를 쉽게 볼 수 있게하려고 이미지를 칼라-> 흑백, 축소하고 크기 해상도 줄임
```
https://blog.scottlogic.com/2020/11/23/ffmpeg-webassembly.html

### 정보 합성

정보 합성이란 ? 문서에서 정보의 요점을 추출하는 것. 트랜스코딩 과정에서 유용할 수 있음

```jsx
ex) 각 절의 제목에 기반한 문서의 개요 생성/페이지에서 광고 및 로고 제거
```

포털 사이트의 자동화된 웹페이지 분류 시스템에 의해 종종 사용됨.

### 내용 주입

웹 문서의 양을 늘리는 종류인 내용 주입 트랜스코딩
