# 17장 내용 협상과 트랜스코딩

## 내용 협상 기법이란?

- 서버에 있는 여러 페이지들 중 특정 상황에 클라이언트에게 어떤 것이 맞는지 판단하는 기법

### 1. 클라이언트 주도 협상

서버가 클라이언트의 요청을 받았을 때 가능한 페이지의 목록을 응답으로 돌려주어 클라이언트가 보고 싶은 것을 선택하게 하는 것

- 여러 가지 버전에 대한 링크와 각각에 대한 설명이 담긴 HTML 페이지 전송

단점 

- 각 페이지에 두 번의 요청 필요. 1. 목록 얻기, 2. 선택한 사본 얻기
- 여러 가지 버전의 URL이 요구됨. www.sample.com/english , www.sample.com/korea

### 2. 서버 주도 협상

클라이언트가 자신이 무엇을 선호하는지에 대한 충분한 정보를 서버에게 주어 서버가 결정하게끔 하는 방식

```jsx
Accept : 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.
Accept-Language : 서버가 어떤 언어로 보내도 되는지 알려준다.
Accept-Charset : 서버가 어떤 차셋(어떤 문자열로 인코딩하는지 ex UTF-8)으로 보내도 되는지 알려준다.
Accept-Encoding : 서버가 어떤 인코딩으로 보내도 되는지 알려준다.
```

HTTP는 상태가 없는 프로토콜이기에 매 요청에 클라이언트는 자신의 선호 정보를 보낼 것

Accept-Language 헤더 정보로 English 를 넣으면 서버는 영어 페이지를 보낼 수 있다.

선호도도 나열할 수 있다. 

```jsx
Accept-Language: en;q=0.5 fr;q=0.0, nl;q=1.0, tr;q=0.0
```

만약, 클라이언트의 선호에 대응하는 문서가 하나도 없을 경우에는,, 문서를 고치거나 트랜스코딩 할 수 있다. → 보기

장점 : 협상을 위한 커뮤니케이션 대기시간이 줄어든다.

### 아파치의 내용 협상 지원 

https://httpd.apache.org/docs/2.4/content-negotiation.html

콘텐츠 제공자가 여러 버전의 파일들을 아파치 서버의 적절한 디렉터리에 모두 넣음

그리고, 둘 중의 한 가지 방법으로 내용 협상을 동작시킴

- 웹 사이트 디렉터리에서, 웹 사이트의 각 URI를 위한 type-map 파일을 만듬. 그 type-map 파일은 모든 배리언트와 그들 각각에 대응하는 내용 협상 헤더들을 나열
- 아파치가 그 디렉터리에 대해 자동으로 type-map 파일을 생성하도록 하는 multiViews 지시어를 켬(요청한 리소스의 이름에 대응하는 협상 헤더를 추측해서 자동생성)

#Q. type-map 파일이란?

아파치 서버의 서버 설정 파일에 type-map 파일들을 위한 파일 접미사를 명시한 핸들러를 추가

```jsx
AddHandler type-map .var
```

```jsx
type-map 파일의 예

URI : joes-hardware.html

URI : joes-hardware.en.html
Content-type: text/html
Content-language : en

URI : joes-hardware.fr.de.html
Content-type: text/html;charset=iso-8859-2(아스키를 기반으로 한 표준 문자 인코딩인 ISO/IEC 8859의 일부)
Content-language: fr,de (프랑스, 독일)
```

- 아파치의 협상방법
```
1. 서버가 주도하는 협상(일반적인 경우)
더 나은 결과를 얻기 위해 종종 특정 범위의 품질계수를 조작
2. 자연스러운(transparent)내용협상
브라우저가 RFC 2295에 정의된 방법으로 요청할 경우에만 사용
'최적의' 변형을 결정할 권한을 브라우저에게 부여. 그래서 결과는 브라우저의 알고리즘에 달렸다.
이 과정 중 브라우저는 아파치에게 RFC 2296에 정의된 '원격 변형선택 알고리즘 요청 가능
```

- 아파치의 협상 알고리즘

아파치는 브라우저에게 보낼 최적의 변형을 선택하기 위해 아래 알고리즘 사용

```
1. 먼저, 협상의 각 범위에 대해 해당하는 Accept* 헤더를 검사하고, 각 변형에 품질값을 매긴다. 어떤 범위의 Accept* 헤더가 받아들이기 않는 변형은 후보에서 제외한다. 어떤 변형도 남지 않으면 4단계로 간다.
2. 다음 각 검사는 순서대로 일어나며, 선택되지 않은 variant는 제외된다. 각 검사 후 한 변형만 남으면 이를 최적의 variant로 선택하고 3단계로 간다.

- 1. Accept 헤더의 품질계수와
```

**variant**란?
- 자원에는 여러 표현들(media type, 문자집합, 인코딩 등을 가진 바이트)이 있을 수 있는데, 여러 표현이 있다면 자원을 협상가능하다고 하며 각 표현을 variant라고 함


### 3. 투명 협상

클라이언트 입장에서 협상하는 중개자 프락시를 둠으로써 클라이언트와의 메시지 교환을 최소화하는 동시에 서버 주도 협상으로 인한 부하를 서버에서 제거

서버는 클라이언트의 요청에 가장 잘 맞는 것이 무엇인지 판별하려면 어떤 요청 헤더를 검사해야 하는지 프락시에게 반드시 말해줄 수 있어야 함. 

캐시가 가미된 내용 협상 동작 과정

![image](https://user-images.githubusercontent.com/38098157/212543795-32347f62-6c28-4326-abde-59c34fb8e20e.png)


처음에는 프랑스어 사용자의 요청을  캐시가 서버에 그대로 전달하고, 응답을 저장

두번째는 스페인어 사용자의 요청을 캐시가 확인하고, 갖고 있는 프랑스어 문서가 해당되는 것이 아니니까 프랑스 문서를 서버에게 그대로 전달하고 그 응답도 저장

이제 캐시는 같은 URL에 대해 두 개의 다른 문서를 갖게 되는데, 이 다른 버전들은 variant 혹은 alternate로 불리기에, 내용 혐상은 variant 중에서 클라이언트의 요청에 가장 잘 맞는 것을 선택하는 과정으로 이해할 수도 있다.

### 다른 헤더에 기초된 내용 협상

서버가 콘텐츠를 판단하는 기준이 User-Agent 같은 Accept 가 아닌 다른 헤더라면, 캐시는 반드시 그 헤더가 무엇인지 알아야 한다.

HTTP Vary 응답 헤더를 사용해 명시한다.

```jsx
Vary: User-Agent, Cookie
```

새 요청이 도착해서 캐시가 내용 협상 헤더들을 이용해 가장 잘 맞는 것을 찾을 때, 캐시는 반드시 응답 안에 서버가 보낸 Vary 헤더가 들어있는지 확인한다.

존재한다면, Vary 헤더가 명시하고 있는 헤더들도 내용 협상에 사용해야한다.

![image](https://user-images.githubusercontent.com/38098157/212543820-907cb0fb-763f-438a-a939-698c9c986c52.png)

## 트랜스코딩

만약, 서버가 클라이언트의 요구에 맞는 문서를 갖고 있지 있다면?

이론적으로 서버는 기존의 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수 있는데, 이 옵션을 트랜스코딩이라고 함.

### 포맷 변환

데이터를 클라이언트가 볼 수 있도록 한 포맷에서 다른 포맷으로 변환하는 것

포맷변환은 내용 협상 헤더에 의해 주도됨 

```jsx
ex) 접속 속도가 느리고 고해상도 이미지에 별로 관심이 없는 클라이언트에서 
이미지가 많은 페이지를 쉽게 볼 수 있게하려고 이미지를 칼라-> 흑백, 축소하고 크기 해상도 줄임
```
https://blog.scottlogic.com/2020/11/23/ffmpeg-webassembly.html

### 정보 합성

정보 합성이란 ? 문서에서 정보의 요점을 추출하는 것. 트랜스코딩 과정에서 유용할 수 있음

```jsx
ex) 각 절의 제목에 기반한 문서의 개요 생성/페이지에서 광고 및 로고 제거
```

포털 사이트의 자동화된 웹페이지 분류 시스템에 의해 종종 사용됨.

### 내용 주입

웹 문서의 양을 늘리는 종류인 내용 주입 트랜스코딩
