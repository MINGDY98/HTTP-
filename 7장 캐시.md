# 캐시란?

```
자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치

- 불필요한 데이터 전송을 줄여 네트워크 요금 비용 줄임
- 네트워크 병목을 줄임. 
- 원 서버에 대한 요청을 줄여 서버는 부하를 줄이고 빨리 응답 가능
- 거리로 인한 지연 시간 줄임
```

이번 장의 흐름
- 어떻게 캐시가 성능을 개선하고 비용을 줄이는지
- 비용 효과를 어떻게 측정하는지
- 효과를 극대화하기 위해 캐시를 어디에 위치시켜야하는지
- 어떻게 HTTP가 캐시된 사본을 신선하게 유지하는지
- 어떻게 캐시가 다른 캐시나 서버와 상호작용하는지


`대역폭` : 일반적으로는 통신에서 이용 가능한 최대 전송 속도, 즉 정보를 전송할 수 있는 능력을 뜻하며, 그 기본 단위로는 bps를 사용한다.

## 캐시의 특징
### 대역폭 병목을 줄임
- 대역폭은 네트워크 속도와 문서 크기에 따라 전송시간에 영향을 준다.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다. 그리고, 클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크 속도와 같다
- 그렇기 때문에 로컬 네트워크에 캐시된 문서를 가져오는 것은 네트워크 병목을 줄인다.

### 갑작스런 요청 쇄도(Frash Crowds)를 대처함

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요 (갑작스런 사건 등)
- 갑작스런 요청 쇄도로 인한 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킴
Q.어떻게..?

### 거리로 인한 지연을 줄임

- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴, 그리고 빛의 속도 그자체가 유의미한 지연 유발
- ![스크린샷 2022-09-05 오후 2 48 31](https://user-images.githubusercontent.com/38098157/188369364-adeab4b3-af79-47d9-aa28-57789aeb4b70.png)
- 샌프란시스토에서 보스턴으로 20개의 작은 이미지가 포함된 웹페이지를 요청할때 보다 기계실 근처에서 캐시를 설치하는 것이 문서가 전송되는 거리를 순천 킬로미터에서 수십 미터로 줄일 수 있음

`적중과 부적중` : 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 cache hit(캐시 적중)이라고 부름. 사본이 없다면 그냥 원서버로 전달됨(cache miss, 캐시 부적중)

## 재검사(Revalidation)

- `재검사` : 원 서버 콘텐츠는 변경될 수 있기에 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 검사해야함
- `재검사 적중(느린 적중)` : 콘텐츠가 변경되지 않았다는 304 not modified 응답을 받고, 사본을 클라이언트에게 제공하는 것
- 효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청 정의
  - If-Modified-Since : 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미

|case|의미|
|--|--|
|재검사 적중|서버 객체가 변경되지 않았다면 서버는 클라이언트에게 HTTP 304 Not Modified 응답 보냄|
|재검사 부적중|서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄|
|객체 삭제|서버에 객체가 삭제될 경우 404 Not Found응답을 보내고, 캐시는 사본을 삭제|

### 적중과 재검사 부적중의 구별
- HTTP는 적중과 재검사 부적중 둘다 200 OK를 줌.
- Date 헤더를 이용해 현재 시각과 비교해 응답의 생성일이 더 오래되었다면 캐시된 응답인 것을 알 수 있음. 
- 응답이 얼만 오래되었는지 Age헤더를 이용하는 방법도 존재
## 적중률

`캐시 적중률(문서 적중률)` : 캐시가 요청을 처리하는 비율. 0에서 1까지의 값 혹은 퍼센트로 표현됨.
```
- 캐시가 얼마나 큰지
- 캐시 사용자들의 관심사가 얼마나 비슷한지
- 캐시된 데이터가 얼마나 자주 변경되거나 개인화되었는지
- 캐시가 어떻게 설정되어 있는지에 달려있음
```
- 적중률 40%는 괜찮은 웹캐시

|적중률|의미|개선시 이득|
|--|--|--|
|바이트 적중률|캐시를 통해 제공된 바이트의 비율 표현|대역폭 절약을 최적화|
|문서 적중률|얼마나 많은 웹 트랜잭션을 외부에 내보내지 않았는지 표현|전체 대기시간 줄임|

## 캐시 토폴리지

### 개인 전용 캐시

- 작고 저렴
- 웹브라우저는 개인 전용 캐시를 내장.
- 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있게끔 허용
- 인터넷 익스플로러의 도구>인터넷옵션>검색기록>설정>파일보기>캐시 콘텐츠를 보면 연관된 URL및 문서 만료 시각 나열
- 크롬에서는 특별한 URL인 about:cache를 통해 연결도니느 페이지에서 캐시 콘텐츠의 목록을 볼 수 있음

### 공용 프락시 캐시

- 공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
- 공유된 공용 캐시는 자주 찾는 객체를 단 한번만 가져와 모든 요청에 공유된 사본을 제공함으로써 네트워크 트래픽 줄임
- 수동 프락시를 지정하거나 프락시 자동설정 파일을 설정함으로써 브라우저가 프락시 캐시를 사용하도록 설정가능
- 인터셉트 프락실르 사용함으로써 브라우저의 설정 없이 HTTP 요청이캐시르 통하도록 강제할 수도 있음

### 프락시 캐시 계층들

**![image](https://user-images.githubusercontent.com/38098157/188392898-84f13e9b-98b8-4358-b973-2c3d84f0b485.png)
**

- 작은 캐시에서 캐시 부적중이 발생했을 때, 더 큰 부모 캐시를 볼 수 있도록 하는 구조는 효율적
- 캐시 계층이 깊다면, 프락시 연쇄가 길어진다면, 중간 프락시는 현저한 성능 저하 발생

### 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 단순 캐시 계층 대신 복잡한 캐시망 만듦
캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 커뮤니케이션 결정을 동적으로 내림

```
<콘텐츠 라우팅을 위해 설계된 캐시들이 하는 일>

- URL에 근거해 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거해 특정 부모 캐시를 동적으로 선택
- 부모 캐시에 가기 전, 캐시된 사본을 로컬에서 찾아봄
- 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있게 허용하되, 그들의 캐시를 통한 Internet transit(트래픽이 다른 네트워크로 가는것)은 허용 안함

```

이점 : 서로 다른 조직들이 상호이득을 위해 그들의 캐시를 연결해 서로를 찾아볼 수 있도록 해줌
선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불림
HTTP는 형제 캐시를 지원하지 않기에, 사람들은 인터넷 캐시프로토콜(ICP) 혹은 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜로 HTTP 확장함

## 캐시 처리 단계

![image](https://user-images.githubusercontent.com/38098157/188397385-e800d5c9-bfea-4e88-9fba-dabc1e84919f.png)
![image](https://user-images.githubusercontent.com/38098157/188403979-b5f13e72-5086-4460-a8b3-32c1df894e9f.png)
(캐시의 GET 요청 처리)

### 1. 요청 받기

- 캐시는 네트워크 커넥션에서의 활동을 감지 후 들어오는 데이터를 읽어들임. 고성능 캐시일 경우 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전 트랜잭션 처리 시작

### 2. 파싱

- 요청 메시지를 여러 부분으로 파싱해 헤더 부분을 조작하기 쉬운 자료 구조에 담음 ( 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어줌)

### 3. 검색

- URL을 알아내고, 그에 해당하는 로컬 사본이 있는지 검사 -> 빠른 알고리즘 사용
- 얼마나 오랫동안 객체가 캐시에 머무르고 있었는지, 얼마나 자주 사용되었는지 등 메타데이터가 캐시된 객체에 포함됨

### 4. 신선도 검사

- HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해줌 -> 신선한 것으로 간주됨
- 위 기간이 지나면 신선하지 않은 것으로 간주되며, 캐시는 그 문서를 제공하기전 어떤 변경이 있었느지 재검사 필요.

### 5. 응답 생성

- 응답 헤더는 캐시된 서버 응답 헤더를 토대로 생성. 
- 캐시는 클라이언트에 맞게 이 헤더를 조정해야하는 책임 존재. 예로 클라이언트가 HTTP/1.1응답을 기대하는 상황에서 서버가 다른 버전을 반환했다면 적절하게 번역해야함
- 캐시 신선도 정보(Cache-Control, Age, Expires)헤더를 삽입, 또한 요청이 프락시 캐시를 거쳐갔음을 알려주기 위해 종종 Via 헤더 포함. 단, Date 헤더의 조정은 안됨

### 6. 전송

- 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력함 --> ????????????

### 7. 로깅

- 대부분 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지
- 가장 많이 쓰는 캐시 로그 포맷은 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이지만, 많은 캐시 제품이 커스텀 로그 파일을 허용함

## 사본을 신선하게 유지하기- 문서 만료와 서버 재검사 매커니즘

### 문서 만료

HTTP는 Cache-Control: max-age, Expires헤더로 문서에 유효기간을 붙임

- `Cache=Control : max-age` : max-ag=484200 현재시간에서 유효시간까지의 남은 시간(초단위) 표기
- `Expires`: Fri, 05 Jul2002, 05:00:00 GMT : 유효한 절대 유효기간 명시




