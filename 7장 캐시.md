# 캐시란?

```
자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치

- 불필요한 데이터 전송을 줄여 네트워크 요금 비용 줄임
- 네트워크 병목을 줄임. 
- 원 서버에 대한 요청을 줄여 서버는 부하를 줄이고 빨리 응답 가능
- 거리로 인한 지연 시간 줄임
```

이번 장의 흐름
- 어떻게 캐시가 성능을 개선하고 비용을 줄이는지
- 비용 효과를 어떻게 측정하는지
- 효과를 극대화하기 위해 캐시를 어디에 위치시켜야하는지
- 어떻게 HTTP가 캐시된 사본을 신선하게 유지하는지
- 어떻게 캐시가 다른 캐시나 서버와 상호작용하는지


`대역폭` : 일반적으로는 통신에서 이용 가능한 최대 전송 속도, 즉 정보를 전송할 수 있는 능력을 뜻하며, 그 기본 단위로는 bps를 사용한다.

## 캐시의 특징
### 대역폭 병목을 줄임
- 대역폭은 네트워크 속도와 문서 크기에 따라 전송시간에 영향을 준다.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다. 그리고, 클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크 속도와 같다
- 그렇기 때문에 로컬 네트워크에 캐시된 문서를 가져오는 것은 네트워크 병목을 줄인다.

### 갑작스런 요청 쇄도(Frash Crowds)를 대처함

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요 (갑작스런 사건 등)
- 갑작스런 요청 쇄도로 인한 불필요한 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킴
Q.어떻게..?

### 거리로 인한 지연을 줄임

- 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴, 그리고 빛의 속도 그자체가 유의미한 지연 유발
- ![스크린샷 2022-09-05 오후 2 48 31](https://user-images.githubusercontent.com/38098157/188369364-adeab4b3-af79-47d9-aa28-57789aeb4b70.png)
- 샌프란시스토에서 보스턴으로 20개의 작은 이미지가 포함된 웹페이지를 요청할때 보다 기계실 근처에서 캐시를 설치하는 것이 문서가 전송되는 거리를 순천 킬로미터에서 수십 미터로 줄일 수 있음

`적중과 부적중` : 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 cache hit(캐시 적중)이라고 부름. 사본이 없다면 그냥 원서버로 전달됨(cache miss, 캐시 부적중)

## 재검사(Revalidation)

- `재검사` : 원 서버 콘텐츠는 변경될 수 있기에 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 검사해야함
- `재검사 적중(느린 적중)` : 콘텐츠가 변경되지 않았다는 304 not modified 응답을 받고, 사본을 클라이언트에게 제공하는 것
- 효과적인 재검사를 위해 HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청 정의
  - If-Modified-Since : 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미

|case|의미|
|--|--|
|재검사 적중|서버 객체가 변경되지 않았다면 서버는 클라이언트에게 HTTP 304 Not Modified 응답 보냄|
|재검사 부적중|서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄|
|객체 삭제|서버에 객체가 삭제될 경우 404 Not Found응답을 보내고, 캐시는 사본을 삭제|

### 적중과 재검사 부적중의 구별
- HTTP는 적중과 재검사 부적중 둘다 200 OK를 줌.
- Date 헤더를 이용해 현재 시각과 비교해 응답의 생성일이 더 오래되었다면 캐시된 응답인 것을 알 수 있음. 
- 응답이 얼만 오래되었는지 Age헤더를 이용하는 방법도 존재
## 적중률

`캐시 적중률(문서 적중률)` : 캐시가 요청을 처리하는 비율. 0에서 1까지의 값 혹은 퍼센트로 표현됨.
```
- 캐시가 얼마나 큰지
- 캐시 사용자들의 관심사가 얼마나 비슷한지
- 캐시된 데이터가 얼마나 자주 변경되거나 개인화되었는지
- 캐시가 어떻게 설정되어 있는지에 달려있음
```
- 적중률 40%는 괜찮은 웹캐시

|적중률|의미|개선시 이득|
|--|--|--|
|바이트 적중률|캐시를 통해 제공된 바이트의 비율 표현|대역폭 절약을 최적화|
|문서 적중률|얼마나 많은 웹 트랜잭션을 외부에 내보내지 않았는지 표현|전체 대기시간 줄임|

## 캐시 토폴리지

### 개인 전용 캐시

- 작고 저렴
- 웹브라우저는 개인 전용 캐시를 내장.
- 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있게끔 허용
- 인터넷 익스플로러의 도구>인터넷옵션>검색기록>설정>파일보기>캐시 콘텐츠를 보면 연관된 URL및 문서 만료 시각 나열
- 크롬에서는 특별한 URL인 about:cache를 통해 연결도니느 페이지에서 캐시 콘텐츠의 목록을 볼 수 있음

### 공용 프락시 캐시

- 공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
- 공유된 공용 캐시는 자주 찾는 객체를 단 한번만 가져와 모든 요청에 공유된 사본을 제공함으로써 네트워크 트래픽 줄임
- 수동 프락시를 지정하거나 프락시 자동설정 파일을 설정함으로써 브라우저가 프락시 캐시를 사용하도록 설정가능
- 인터셉트 프락실르 사용함으로써 브라우저의 설정 없이 HTTP 요청이캐시르 통하도록 강제할 수도 있음

### 프락시 캐시 계층들

**![image](https://user-images.githubusercontent.com/38098157/188392898-84f13e9b-98b8-4358-b973-2c3d84f0b485.png)
**

- 작은 캐시에서 캐시 부적중이 발생했을 때, 더 큰 부모 캐시를 볼 수 있도록 하는 구조는 효율적
- 캐시 계층이 깊다면, 프락시 연쇄가 길어진다면, 중간 프락시는 현저한 성능 저하 발생

### 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 단순 캐시 계층 대신 복잡한 캐시망 만듦
캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 커뮤니케이션 결정을 동적으로 내림

```
<콘텐츠 라우팅을 위해 설계된 캐시들이 하는 일>

- URL에 근거해 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거해 특정 부모 캐시를 동적으로 선택
- 부모 캐시에 가기 전, 캐시된 사본을 로컬에서 찾아봄
- 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있게 허용하되, 그들의 캐시를 통한 Internet transit(트래픽이 다른 네트워크로 가는것)은 허용 안함

```

이점 : 서로 다른 조직들이 상호이득을 위해 그들의 캐시를 연결해 서로를 찾아볼 수 있도록 해줌
선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불림
HTTP는 형제 캐시를 지원하지 않기에, 사람들은 인터넷 캐시프로토콜(ICP) 혹은 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜로 HTTP 확장함

## 캐시 처리 단계

![image](https://user-images.githubusercontent.com/38098157/188397385-e800d5c9-bfea-4e88-9fba-dabc1e84919f.png)
![image](https://user-images.githubusercontent.com/38098157/188403979-b5f13e72-5086-4460-a8b3-32c1df894e9f.png)
(캐시의 GET 요청 처리)

### 1. 요청 받기

- 캐시는 네트워크 커넥션에서의 활동을 감지 후 들어오는 데이터를 읽어들임. 고성능 캐시일 경우 여러 개의 들어오는 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전 트랜잭션 처리 시작

### 2. 파싱

- 요청 메시지를 여러 부분으로 파싱해 헤더 부분을 조작하기 쉬운 자료 구조에 담음 ( 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어줌)

### 3. 검색

- URL을 알아내고, 그에 해당하는 로컬 사본이 있는지 검사 -> 빠른 알고리즘 사용
- 얼마나 오랫동안 객체가 캐시에 머무르고 있었는지, 얼마나 자주 사용되었는지 등 메타데이터가 캐시된 객체에 포함됨

### 4. 신선도 검사

- HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 해줌 -> 신선한 것으로 간주됨
- 위 기간이 지나면 신선하지 않은 것으로 간주되며, 캐시는 그 문서를 제공하기전 어떤 변경이 있었느지 재검사 필요.

### 5. 응답 생성

- 응답 헤더는 캐시된 서버 응답 헤더를 토대로 생성. 
- 캐시는 클라이언트에 맞게 이 헤더를 조정해야하는 책임 존재. 예로 클라이언트가 HTTP/1.1응답을 기대하는 상황에서 서버가 다른 버전을 반환했다면 적절하게 번역해야함
- 캐시 신선도 정보(Cache-Control, Age, Expires)헤더를 삽입, 또한 요청이 프락시 캐시를 거쳐갔음을 알려주기 위해 종종 Via 헤더 포함. 단, Date 헤더의 조정은 안됨

### 6. 전송

- 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력함 --> ????????????

### 7. 로깅

- 대부분 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지
- 가장 많이 쓰는 캐시 로그 포맷은 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이지만, 많은 캐시 제품이 커스텀 로그 파일을 허용함

## 사본을 신선하게 유지하기- 문서 만료와 서버 재검사 매커니즘


HTTP는 Cache-Control: max-age, Expires헤더로 문서에 유효기간을 붙임

- `Cache=Control : max-age` : max-ag=484200 현재시간에서 유효시간까지의 남은 시간(초단위) 표기
- `Expires`: Fri, 05 Jul2002, 05:00:00 GMT : 유효한 절대 유효기간 명시

HTTP 조건부 메서드 : 재검사를 효율적으로 만들어줌, GET 요청 메시지에 조건부 헤더를 추가함으로서 보내진다.
### `If-Modified-Since: <date>`(IMS 요청): 만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드 처리한다. -> 조건이 참이된다.
콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해  Last Modified 서버 응답 헤더가 오면 사용된다.
### `If-None-Match: <tags>` : 마지막 변경된 날짜를 맞춰보는 대신, 서버는 특별한 태그 제공. 서버에 있는 문서의 태그와 캐시된 태그가 다를 때 요청을 처리
ex) 퍼블리셔가 문서를 수정하고 문서의 엔티티 태그를 새로운 버전으로 만들수있음
: 변경이 너무 사소하거나 변경해도 내용이 똑같아 다시 문서를 받아오지 않아도되는경우 사용

- 약함 검사기 
: HTTP/1.1 은 콘텐츠가 조금 변경되었더라도 그 정도면 같은 것이라고 서버가 주장할 수 있도록 해주는 약한 검사기 지원
w/접두사로 약한 검사기를 구별함 ex If-None-Match: W/"v2.6"
- 강한 검사기
- : 콘텐츠가 바뀔 때마다 바뀜. 

## 캐시제어


HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의

### Cache-Control : no-store / no-cache 헤더를 응답에 첨부할 수 있다.

- 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막음
- no-store가 표시된 응답은 캐시가 그 응답의 사본을 만든느 것을 금지. 캐시를 절대로 해서는 안되는 리소스.
- no-cache로 표시된 응답은 재검사르 하지 않고 캐시에서 클라이언트로 제공되는 것을 금지 (ex HTTP1.0은 Pragma: no-cache만 이해함)

### Cache-Control : Max-Age 응답 헤더

- 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간(초)
- 서버가 0으로 설정해서 보냄으로서 매접근마다 리프레시/캐시하지 않도록 요청 가능

### Expires 응답 헤더

- 실제 만료 날짜 명시
- 몇몇 서버는 문서를 항상 만료되도록 하기 위해 Expires:0 응답 헤더를 돌려보내지만 이는 문법 위반

### Cache-Control :Must-revalidate 응답헤더

- 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미

### 휴리스틱 만료

- 만약 응답이 Cache-Control:max-age헤더나 Expires 헤더 어느 것도 포함하지 않으면 캐시는 경험적인 방법(휴리스틱)으로 최대 나이를 계산
- 휴리스틱 신선도 유지기간 상한선 : 최대 나이 값이 24시간보다 크면 Heuristic Expiration 경고 헤더가 응답헤더에 추가됨. -> 현재 사용자가 볼 수 있게하는 브라우저는 거의 없음

```
* 유명한 휴리스틱 만료 알고리즘인 LM 인자 알고리즘

- 캐시된 문서가 마지막으로 변경된 것이 예전이라면 캐시에 더 오래 보관하게끔 설계
- 최근에 변경되었다면 자주 변경될 것이기에 짧은 시간 동안 캐시한다.

이러한 경험을 캐시의 신선도 지속기간에 반영한다.
```

### 아파치로 HTTP 헤더 제어하는 예제

- mod_headers 모듈
: 개별 헤더들을 설정할 수 있게해줌. 
- mod_expires 모듈
: 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직 제공
- mod_cem_meta
: HTTp 헤더들의 파일을 특정 객체와 연결시켜준다. 각 메타파일에 원하는 헤더를 추가해주면 됨

### HTTP-EQUIV 를 통해 HTML 캐시 제어하기

- 저자가 웹서버 설정 파일과의 상호작용 없이도 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 하기 위해 HTML 2.0은 <META HTTP-EQUIV> 태그를 정의
- HTML 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의
- 그러나, 문제를 일으킴

### 네트워크 지연에 대한 보상
  
HTTP/1.1 쩐체 왕복 시간을 통해 왕복 지연을 계산해 네트워크 지연을 보수적으로 교정

  
## toss에서 HTTP 캐시를 사용하는 노하우
  
- 캐시를 잘못 관리했을 때, 원하는 시점에 캐시가 사라지지 않을 수 있고 필요이상으로 HTTP 요청이 발생하기도함

- Cache-Control 헤더를 섬세하게 조절해야함
- HTTP 요청 후 응답이 올 때, 응답에 포함된 Cache-Control 헤더에 따라 받은 리소스의 생명 주기가 결정됨
  
- 개발자 도구
  
  ![image](https://user-images.githubusercontent.com/38098157/189663373-6a2ba361-0b01-4874-8693-7bb67b0f960a.png)

를 보면, from memory cache로 표기된 것 을 볼 수 있음..
  
(*)주의 : CDN Invalidation을 포함한 서버의 어떤 작업이 있어도 브라우저의 유효한 캐시를 지우기는 어려움. 한 번 브라우저에 캐시가 저장되면 만료될 때까지 캐시는 계속 브라우저에 남아있게됨
  
### CDN Invalidation
  
- 캐시를 없애기 위해서 일반적으로 CDN Invalidation을 수행한다고 이야기함
- 캐시를 지우려면, 브라우저 및 중간 서버 각각에 대해 직접 캐시를 삭제해야함
- Cache-Control의 max-age값은 신중히하기
  max-age=값을 설정하면, 매번 리소스 요청마다 서버에 재검증 요청을 보내는데, 일부 모바일 브라우저의 경우에는 웹 브라우저를 껏따 켜기 전까지 리소스가 만료되지 않도록 하는 것을 선호하는 경우가 있음. 네트워크 요청을 아끼고 사용자에게 빠른 웹 경험을 제공하기 위해서임. -> no-store값 사용
  
  
### Cache-Control: public과 private
  
- CDN과 같은 중간 서버가 특정 리소스를 리소스를 캐시할 수 있는지 여부를 지정하기 위해 Cache-Control 헤더 값으로 public 또는 private를 추가할 수 있음

  - public : 모든 사람과 중간 서버가 캐시를 저장할 수 있음
  - private : 가장 끝의 사용자 브라우저만 캐시를 저장할 수 있음
  
```
  ex) Cache-Control : public, majx-age=8400
```
  
### s-maxage
- 중간 서버에서만 작용되는 max-age값 설정

### toss의 전략
  
#### JS, CSS 파일

- JS,CSS파일은 웹 서비스를 빌드할 때마다 새로 생김, 토스 프론트엔드 챕터는 임의의 버전 번호를 URL 앞부분에 붙여서 빌드 결과물마다 고유한 URL을 가지도록 설정
- 이때,같은 URL에 대해 내용이 바뀔 수 있는 경우는 없음
  -> max-age=31536000(최대치) 설정함.
  
#### HTML 파일
  
- HTML 리소스는 새로 배포가 이루어질 때마다 값이 바뀔 수 있음.
-> max-age=0, s-maxage=31536000으로 설정
  대신, 배포가 이루어질 때마다 CDN Invalidation 발생시켜 CDN이 서버로부터 새로운 HTML 파일을 받아오도록 설정
