이번 장의 목적

- 메세지의 흐름
- HTTP 메시지의 세 부분
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들이 하는 일

메서지의 흐름
※프락시 :

웹 보안, 애플리케이션 통합, 성능 최적화를 위한 중요한 구성요소인 프락시 서버
클라이언트의 모든 HTTP 요청을 받아 수정을 거쳐 서버에 전달
보안을 위해 사용 - 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할. 즉 요청과 응답 필터링
애플리케이션 받을때 바이러스 검출 혹은 학생들에게 성인 콘텐츠 차단

메세지는 클라이언트, 서버, 프락시 사이를 흐름
메세지의 방향을 의미하는 용어 '언바운드', '아웃바운드', '업스트림', '다운 스트림' 존재

트랜잭션 방향에 따라 인바운드, 아웃바운드
- 인바운드 : 메시지가 원 서버로 향하는 것
- 아웃바운드 : 모든 처리 후에 사용자 에이전트로 돌아오는 것

요청메시지냐 응답 메시지냐에 관계 없이 모든 메시지는 다운스트림으로 흐름

메시지 구성요소/문법
시작줄, 헤더, 본문으로 이루어짐
시작줄, 헤더 각 내용은 줄바꿈 문자열로 각 줄이 끝남 'CRLF'
본문은 선택 : empty/text/binary data
헤더는 본문의 정보를 제공 Content-type:본문이 무엇인지, Cotent-length: 본문의 크기
요청메시지

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```
ex)
GET /specials/saw-blade.gif HTTP/1.0
Host: www.joes-hardware.com


응답메시지

```
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```
ex)
HTTP/1.0 200 OK
Content-Type: image/gif
Content-length: 8572


* HTTP/1.0 이전 시절에는 응답에 요청줄/응답줄(시작줄)이 들어있을 필요가 없었다.

* HTTP/0.9는 요청은 메서드와 요청 URL만 있고, 응답은 오직 엔터티만 되어있어서 대부분의 기능들을 구현할수없다.



메서드	
클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작

모든 서버가 모든 메서드를 구현하지 않으며 서버별로 쓰는 메서드가 있을수있다.

요청 URL	요청 대상의 리소스를 지칭
버전	
사용중인 HTTP버전

HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단

버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리키는 것이기에 그 버전까지 이해할 수 있음을 의미하는 것

버전 번호는 분수가 아니라 각각 분리된다 ex HTTP/1.0은 1과 0이 분리되어서 HTTP/2.22가 HTTP/2.3보다 크다.

상태코드	
요청 중에 무엇이 일어났는지 (트랜잭션을) 설명하는 숫자(첫번째자리-'성공','에러등 분류)


만약 정의된 범위에 없는 상태코드를 받게되더라도, 전체 범위의 분류를 고려하는 것이 좋다.

사유 구절	
상태 코드의 의미를 사람이 이해하도록 설명

상태 코드와 일대일로 대응되며, 상태 코드에 대한 글로된 설명 제공, HTTP 명세는 사유 구절에 대한 엄격한 규칙을 제공하지 않음

헤더	
0개/1개/여러개 HTTP 헤더 존재

애플리케이션은 자유롭게 자신의 헤더를 만들 수 있음

이름, 콜론(:) 값, 공백(선택), CRLF가 한 세트

* 헤더의 집합은 항상 빈 줄 CRLF로 끝나야함






메서드
안전한 메서드
GET,HEAD 메서드와 같이 HTTP 요청의 결과로 서버에 어떤 작용이 없음을 의미하는 메서드

→ 웹 개발자에게 달린거라 서버에 작용을 유발하지 않는다는 보장은 없음

GET	
서버에게 리소스를 달라고 요청시 쓰임

HTTP/1.1은 서버가 이 메서드를 구현하게함

HEAD	
GET과 행동이 같으나, 응답으로 헤더만 줌

이점

리소스를 가져오지 않고도, 어떤 것인지 알수 있음
상태 코드를 통해 개체가 존재하는지 확인할 수 있음
헤더를 확인해 리소스가 변경되었는지 감시할 수 있음
HTTP/1.1준수를 위해 HEAD 메서드 반드시 구현되어야함

PUT	서버에 요청의 본문으로 요청 URL의 이름으로 새 문서를 만들거나, 이미 존재한다면 교체
POST	서버에 입력 데이터를 전송하기 위해 설계
TRACE	
클라이언트에게 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌

요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션에서 수정될 수가 있는데 TRACE를 통해 수정/망가졌는지 확인 가능 → 진단용으로 사용 가능

OPTIONS	특정 리소스에 대해 지원되는 메서드
DELETE	
리소스 삭제 요청

but, 서버는 그 요청을 무시 가능, 삭제 수행 보장X

이외에도 확장 메서드 존재



상태 코드


중분류	상태코드	사유구절(추천)	의미
100-199

정보성 상태 코드

100	Continue	
요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야함을 의미

클라이언트가 100-Continue응답을 기대한다면, 값을 100-continue로 하는 Expect 요청 헤더를 보내야 함
에러 등의 이유로 100continue응답을 주지않고 요청을 끝내기로 결정했다면, 서버는 그냥 응답을 보내고 연결을 닫아서는 안됨

101	Switching Protocols	클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미


200-299 : 성공 상태 코드





<느낀점>

흥미로운 202

204,205처럼 클라이언트에게 동작을 요구하는 건 매우 흥미롭다.

206처럼 클라이언트가 특별한 헤더를 사용해 문서의 특정 범위를 요청할 수 있다는 사실.. 

특정 범위의 요청을 이때까지는 그냥 요청했는데 특별한 헤더를 사용한다니 놀라움



300-399 : 리다이렉션 상태 코드

클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나, 그 리소스의 내용 대신 다른 대안 응답을 제공

HEAD가 아닌 요청에 대해 리다이렉트될 URL링크와 설명을 포함시키는 것이 좋은 습관
리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을때 유효한지 확인하기 위해 사용됨







300 협상 매우 흥미롭다.

302,303,307 상태 코드 사이에 중복되는 부분 존재

→ HTTP/1.0과 HTTP/1.1 애플리케이션이 이 상태 코드를 다루는 방식의 차이점에서 기인



400-499 클라이언트 에러 상태 코드



405 요청→ 응답



408을 통해 서버에서 먼저 연결을 끊을 수 있다는 점이 흥미로움.



500-599 서버 에러 상태 코드

프락시가 클라이언트 입장에서 서버와 대화를 시도할 때 만나게 되는 에러
클라이언트가 서버의 제한에 걸린 것일 수도, 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일수도있음


503 - 다음을 기약하는 응답도 있다.

헤더


일반 헤더	
클라이언트와 서버 양쪽 모두 사용

ex)

메시지가 만들어진 일시를 지칭하기 위해 사용

Date: Tue, 3 Oct 1974 02:16:00 GMT



일반 캐시 헤더

애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 헤더

요청 헤더	
요청 메시지를 위한 헤더

누가/무엇이 요청을 보냈는지에 대한 정보 


or 클라이언트의 선호나 능력에 대한 정보



ex)

서버에게 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미

Accept : */*



조건부 요청 헤더
ex) 클라이언트가 이미 어떤 문서의 사본을 갖고 있는 상태라면, 그 문서를 요청시 자신이 갖고 있는 사본과 다를때만 전송해달라고 요청하고 싶을때

서버에게 요청에 응답하기 전 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있음





요청 보안 헤더
요청하는 클라이언트가 어느 정도의 리소스에 접근하기 전 자신을 인증하게 함으로써 트랜잭션을 더 안전하게 만들고자 하는 모 ㄱ적





프락시 요청 헤더
프락시의 기능을 돕기 위한 헤더 → 후에 깊이 다룸



응답 헤더	
누가 응답을 보내고 있는지, 응답자의 능력은 어떤지, 응답에 대한 특별한 설명 제공, 클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 할 수 있도록 도와줌



협상 헤더
: 서버와 클라이언트가 협상을 할 수 있도록 지원하는 헤더

응답 보안 헤더


ex)

클라이언트에게 Tiki-Hut 서버 1.0버전과 대화하고 있음을 말해줌.

Server: Tiki-Hut/1.0

엔티티 헤더	
엔티티와 그것의 내용물에 대한 객체의 타입부터 주어진 리소스에 대해 요청할 수 있는 유효한 메서드들까지 광범위한 정보 제공

일반적으로 메시지 수신자에게 자신이 다루고 있는 것이 무엇인지 말해줌

엔티티 정보 헤더


콘텐츠 헤더
: 엔티티 콘텐츠에 대한 구체적인 정보 제공



엔티티 캐싱 헤더
언제 어떻게 캐시가 되어야 하는지 지시자 제공

확장 헤더	
애플리케이션 개발자에 의해 만들어졌지만 아직 HTTP 명세에는 추가되지 않은 비표준 헤더

HTTP 프로그램은 확장 헤더에 대해 모른다해도 용인하고 전달해야할 필요 존재





클라이언트 에러 상태 코드 405 : 요청한 URL에 대해 지원하지 않는 메서드로 요청받았을때 사용, 어떤 메서드가 사용 가능한지 클라이언트에게 알려주고 싶다면 요청시 ALLOW 엔티티 정보 헤더가 필요하다.



의문점 1 : 응답 상태코드는 내용은 백엔드 프레임워크에서 만들어주는지?

→ Spring MVC에서 자동으로 생성







