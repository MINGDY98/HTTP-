#### 배울 내용
- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

### TCP


> 메시지 전송 과정

- 연결된 TCP 커넥션을 통해 메시지 데이터의 내용을 순서대로 보냄
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고 세그먼트를 IP패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달

*각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달됨

```
<IP 패킷의 정보>
- IP 패킷 헤더(보통 20바이트)
- TCP 세그먼트 헤더(보통 20바이트)
- TCP 데이터 조각(0 혹은 그 이상의 바이트)
```
![](https://velog.velcdn.com/images/pigu/post/6faaeb90-d6f8-4889-ae6f-706384f11d1e/image.png)

* IP 패킷 속 TCP 세그먼트(TCP 데이터 스트림의 덩어리를 운반하는)가 보임.

> TCP 커넥션 유지

- 컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있고, TCP는 포트 번호를 통해 이런 여러 개 커넥션 유지
	- IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결됨
    
- TCP 커넥션은 네 가지 값으로 식별됨
`<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`

> TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능 제공 ex 소켓 API

- 소켓 API를 사용하면, TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있음.
- TCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨김
![](https://velog.velcdn.com/images/pigu/post/1ee95364-fb69-4a95-b745-398fb1d741ab/image.png)

웹 서버는 커넥션 생성은 서버와의 거리, 서버의 부하, 인터넷 혼잡도에 따라 시간이 걸림


> TCP 성능에 대한 고려


- 먼저, HTTP 트랜잭션 지연시키는 원인을 알아보자
![](https://velog.velcdn.com/images/pigu/post/d05fc93e-504f-4a2a-a496-7da87dd2f1c2/image.png)

: 처리보다는 TCP 설정, 요청, 응답메시지를 보내는 것이 오래 걸린다.(즉 HTTP는 TCP 바로 위에 있는 계층이기에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받음)

`TCP 네트워크 지연`

```
1. 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야함. 
만약 URI에 기술되어 있는 호스트에 방문한 적이 최근에 없으면
DNS 이름 분석 인프라를 사용해 URI에 있는 호스트 명을 IP 주소로 변환하는데 수십초의 시간이 걸릴 것

2.TCP 커넥션 요청을 보내고, 서버가 커넥션 응답을 회신하기를 기다리는 커넥션 설정 시간
보통 1~2초가 소요되나, 수백개의 HTTP 트랜잭션이 만들어지면 소요시간은 클 것

3. 요청 메시지가 인터넷을 통해 전달되고 서버에 의해 처리되고, 응답을 보내는 시간
```

#### HTTP 프로그래머에게 영향을 주는 가장 일반적인 TCP 관련 지연

- TCP 커넥션의 핸드웨이크 설정


![](https://velog.velcdn.com/images/pigu/post/bcc8bae8-d1f9-4410-8748-d53e564f58aa/image.png)
```
SYN : 커넥션 요청
SYN+ACK : 커넥션 요청이 받아들여짐
ACK : 커넥션이 잘 맺어졌다는 확인응답 (+ 오늘날은 데이터까지 함께 )

크기가 작은 HTTP 트랜잭션에게는 커다란 크기 -> 이미 존재하는 커넥션을 HTTP가 재활용해야함!
```
- 인터넷 혼잡을 제어하기 위한 TCP의 느린 시작

```
급작스런 부하와 혼잡을 방지하기 위해 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도를 높임
이렇게 이미 어느 정도 데이터를 주고받은 커넥션을 '튜닝'된 커넥션이라함.
```

- 데이터를 한데 모아 한 번에 전송하기 위한 네이글 알고리즘

```
네트워크 효율을 위해 패킷 전송 전 많은 양의 TCP 데이터를 한 개의 덩어리로 합치는 알고리즘

<문제점>
- 크기가 작은 HTTP 메시지는 패킷을 채우지 못해 대기를 해야하여 지연됨
- 네이글 알고리즘은 확인응답 지연과 함께 쓰일 경우 형편없이 동작함(네이글 알고리즘은 확인 응답이 도착할 때까지 데이터 전송을 멈추고 있는 반면, 확인응답 지연 알고리즘은 확인응답을 100~200밀리초 지연시킴)

-> HTTP 스택에 TCP_NODELAY 파라메터 값을 설정해 네이글 알고리즘을 비활성화하기도함

```
- TCP의 편승 확인응답을 위한 확인응답 알고리즘
- TIME_WAIT 지연과 포트 고갈

```

TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종담에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해놓음
이는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간동안 생성되지 않게 하여
이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지함 (2분, 2MSL이라 불림)
-> 성능시험에서 문제 발생 가능 (성능 측정 대상 서버는 클라이언트가 접속할 수 있는 IP 주소 개수를 제한해서)
-> 순간순간 포트르 재활용해지는것이 불가능해짐
```

#### HTTP 커넥션 관리

> 먼저 HTTP Connection header에 대해 알아보자

- HTTP 메시지는 클라이언트와 서버 사이에 중개 서버(프락시 서버, 캐시 서버)를 거치며 전달되는데ㅔ, 어떤 경우에는 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야할 때가 있음
-> Connection 헤더 속 hop-by-hop 헤더명 기술 (헤더 보호하기)
	수신자가 요청온 옵션을 모두 적용한 후 다음 hop에 메시지 전달하기 전에 Connection 헤더와 Connection 헤더에 기술되어 있던 모든 헤더 삭제
