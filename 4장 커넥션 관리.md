### 배울 내용
- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

### TCP


#### 메시지 전송 과정

- 연결된 TCP 커넥션을 통해 메시지 데이터의 내용을 순서대로 보냄
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고 세그먼트를 IP패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달

*각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달됨

```
<IP 패킷의 정보>
- IP 패킷 헤더(보통 20바이트)
- TCP 세그먼트 헤더(보통 20바이트)
- TCP 데이터 조각(0 혹은 그 이상의 바이트)
```
![](https://velog.velcdn.com/images/pigu/post/6faaeb90-d6f8-4889-ae6f-706384f11d1e/image.png)

* IP 패킷 속 TCP 세그먼트(TCP 데이터 스트림의 덩어리를 운반하는)가 보임.

#### TCP 커넥션 유지

- 컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있고, TCP는 포트 번호를 통해 이런 여러 개 커넥션 유지
	- IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결됨
    
- TCP 커넥션은 네 가지 값으로 식별됨
`<발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>`

#### TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능 제공 ex 소켓 API

- 소켓 API를 사용하면, TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있음.
- TCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, 그리고 TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨김
![](https://velog.velcdn.com/images/pigu/post/1ee95364-fb69-4a95-b745-398fb1d741ab/image.png)

웹 서버는 커넥션 생성은 서버와의 거리, 서버의 부하, 인터넷 혼잡도에 따라 시간이 걸림


#### TCP 성능에 대한 고려


- 먼저, HTTP 트랜잭션 지연시키는 원인을 알아보자
![](https://velog.velcdn.com/images/pigu/post/d05fc93e-504f-4a2a-a496-7da87dd2f1c2/image.png)

: 처리보다는 TCP 설정, 요청, 응답메시지를 보내는 것이 오래 걸린다.(즉 HTTP는 TCP 바로 위에 있는 계층이기에 HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받음)

`TCP 네트워크 지연`

```
1. 클라이언트는 URI에서 웹 서버의 IP 주소와 포트 번호를 알아내야함. 
만약 URI에 기술되어 있는 호스트에 방문한 적이 최근에 없으면
DNS 이름 분석 인프라를 사용해 URI에 있는 호스트 명을 IP 주소로 변환하는데 수십초의 시간이 걸릴 것

2.TCP 커넥션 요청을 보내고, 서버가 커넥션 응답을 회신하기를 기다리는 커넥션 설정 시간
보통 1~2초가 소요되나, 수백개의 HTTP 트랜잭션이 만들어지면 소요시간은 클 것

3. 요청 메시지가 인터넷을 통해 전달되고 서버에 의해 처리되고, 응답을 보내는 시간
```

### HTTP 프로그래머에게 영향을 주는 가장 일반적인 TCP 관련 지연

#### TCP 커넥션의 핸드웨이크 설정


![](https://velog.velcdn.com/images/pigu/post/bcc8bae8-d1f9-4410-8748-d53e564f58aa/image.png)
```
SYN : 커넥션 요청
SYN+ACK : 커넥션 요청이 받아들여짐
ACK : 커넥션이 잘 맺어졌다는 확인응답 (+ 오늘날은 데이터까지 함께 )

크기가 작은 HTTP 트랜잭션에게는 커다란 크기 -> 이미 존재하는 커넥션을 HTTP가 재활용해야함!
```
#### 인터넷 혼잡을 제어하기 위한 TCP의 느린 시작

```
급작스런 부하와 혼잡을 방지하기 위해 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도를 높임
이렇게 이미 어느 정도 데이터를 주고받은 커넥션을 '튜닝'된 커넥션이라함.
```

#### 데이터를 한데 모아 한 번에 전송하기 위한 네이글 알고리즘

```
네트워크 효율을 위해 패킷 전송 전 많은 양의 TCP 데이터를 한 개의 덩어리로 합치는 알고리즘

<문제점>
- 크기가 작은 HTTP 메시지는 패킷을 채우지 못해 대기를 해야하여 지연됨
- 네이글 알고리즘은 확인응답 지연과 함께 쓰일 경우 형편없이 동작함(네이글 알고리즘은 확인 응답이 도착할 때까지 데이터 전송을 멈추고 있는 반면, 확인응답 지연 알고리즘은 확인응답을 100~200밀리초 지연시킴)

-> HTTP 스택에 TCP_NODELAY 파라메터 값을 설정해 네이글 알고리즘을 비활성화하기도함

```
#### TCP의 편승 확인응답을 위한 확인응답 알고리즘
#### TIME_WAIT 지연과 포트 고갈

```

TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종담에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해놓음
이는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간동안 생성되지 않게 하여
이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지함 (2분, 2MSL이라 불림)
-> 성능시험에서 문제 발생 가능 (성능 측정 대상 서버는 클라이언트가 접속할 수 있는 IP 주소 개수를 제한해서)
-> 순간순간 포트르 재활용해지는것이 불가능해짐
```

### HTTP 커넥션 관리

> 먼저 HTTP Connection header에 대해 알아보자

- HTTP 메시지는 클라이언트와 서버 사이에 중개 서버(프락시 서버, 캐시 서버)를 거치며 전달되는데ㅔ, 어떤 경우에는 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야할 때가 있음
-> Connection 헤더 속 hop-by-hop 헤더명 기술 (헤더 보호하기)
	수신자가 요청온 옵션을 모두 적용한 후 다음 hop에 메시지 전달하기 전에 Connection 헤더와 Connection 헤더에 기술되어 있던 모든 헤더 삭제
    
    
#### 순차적인 트랜잭션 처리에 의한 문제점

`Q. 3개의 이미지가 있는 웹페이지를 보여주려면 몇개의 트랜잭션이 필요?`
-> 1개(HTML을 받기 위함) + 3개(첨부된 이미지를 받기 위함)

- 각 트랜잭션이 새로운 커넥션을 필요로 하면 커넥션을 맺는데 발생하는 지연 + 느린 시작 지연 각각 발생
- 물리적인 지연 + 심리적인 지연 (공간에 변화가 없기에 , + 특정 브라우저의 경우 객체 크기로 인해 모든 객체를 내려받기 전까지 빈 화면보여주는 문제)

#### 커넥션 성능 향상 시킬 수 있는 최신 기술

- 병렬 커넥션

```
클라이언트가 동시에 여러 커넥션을 맺음으로써 여러개의 HTTP 트랜잭션을 병렬로 처리할 수 있게함
일반적으로 빠름 : 커넥션 지연이 겹쳐짐으로써 총 지연시간이 줄어듬
그렇지 않은 경우 : 네트워크 대역폭이 좁을 때, 즉 데이터 전송하는 것에 시간이 오래 걸릴때 지연시간을 줄일 수 있는 이점이 줄어드니 빠르지 않을 경우가 있음.또한, 다수의 커넥션은 메모리를 많이 소모하고 성능 문제 발생 가능

실제로, 브라우저는 병렬 커넥션을 적은수로 허용. 커넥션이 많아질 경우 서버가 임의로 끊을 수도 있음.
```
- 지속 커넥션

```

사이트 지역성 : 웹페이지의 이미지 대부분이 같은 웹 사이트에 있어 같은 서버에 또 요청하게 되는 현상
- 지속 커넥션 : HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다.
-> TCP의 느린 시작으로 인한 지연을 피함

단점 : 지속 커넥션을 잘못 관리할 경우 , 수많은 커넥션이 쌓이며, 불필요 리소스 소모 발생

현재 애프리케이션 : 병렬 커넥션 + 지속커넥션 (keep-alive(HTTP/1.0+), 지속 커넥션(HTTP/1.1))



<Keep-Alive>

- 더이상 사용하지 않기로 결정되어 HTTP/1.1명세에서 빠짐. 하지만 아직도 브라우저와 서버간에 keep-alive 핸드셰이크가 널리 사용되고 있기에 HTTP 애플리케이션은 그것을 처리할 수 있게 개발해야함.

요청에 Connection:Keep-Alive 헤더를 포함. 이 요청을 받은 서버는 그 다음 요청도 이 커넥션을 통해 받고 싶다면, 응답 메시지에 같은 헤더를 포함시켜 응답.
-> keep alive를 받았다고해서 그렇게 할 필요는 없음.
- 엔티티 본문의 길이를 알 수 있어야 트랜잭션 끝나는 시점에 
기존 메시지의 끝과 새로운 메시지의 시작점을 정확히 알기때문에 커넥션을 유지할 수 있음 
(엔티티 본문이 정확한 Content-length 값과 함께 멀티파트 미디어(multipart media type)형식을 가지거나
청크 전송 인코딩(CHunked transfer encoding)으로 되어있어야함.

- 프락시와 게이트웨이는 Connect 헤더 규칙을 철저히 지켜야함
정석대로면, keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안되지만 현실적으로 쉽지 않음.->dumb 프락시로 인해 발생할 문제 예방

- 기술적으로 HTTP/1.0을 따르는 기기로부터 받는 모든 Connection 헤더 필더는 무시해야함. 

- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우, 별다른 문제가 없으면 요청을 다시 보낼 수 있게 준비되어 있어야 한다.

```


#### dumb 프락시에서 Keep-Alive를 사용할 때 생기는 문제

- keep-alive 헤더가 지워지지 않고 프락시에 의해 보내지기 때문에, 커넥션을 끊지 않음.
- 프락시는 커넥션이 끊어지기 전까지 커넥션이 끊어지는 것을 기다리는데, 같은 커넥션상에서 다른 요청이 오는 경우는 예상하지 못해서 그 요청은 프락시로부터 무시되고 브라우저는 응답 없음. 결국 타임아웃으로 인해 커넥션이 끊길 때까지 기다림

#### Proxy-Connection

- HTTP 최신 버전을 지원하지 않아도, 모든 헤더를 무조건 전달하는 문제를 해결할 수 있는 차선책 제시
Connection 대신 비표준 Proxy-Connection 확장 헤더 전달
	- 멍청한 프락시는 이것을 무시하고 영리한 프릭시는 의미 있는 Connection 헤더로 바꾸어 사용
    - but, 멍청한 프락시 양옆에 영리한 프락시가 있다면 동일 문제 발생



#### HTTP/1.1의 지속 커넥션

- http/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원
- 지속 커넥션을 기본으로 활성화해서 별도 설정 안해도 모든 커넥션을 지속 커넥션으로 취급.
- 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection:close 헤더 명시 필요
- 하지만 역시 언제든지 클라이언트와 서버는 커넥션을 끊을 수 있음.
- http/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야함

#### 파이프라인 커넥션
- http/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝 할 수 있고, 이는 keep-alive 커넥션의 성능을 더 높여줌.
- 파이프라인 커넥션은 전송 대기 시간을 단촉시킴

```
<제약사항>
- HTtp 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안됨
- http 응답은 요청 순서와 같게 와야함.http 메시지에는 순번이 없어 순선에 맞게 정렬시킬 방법이 없기에
- http 클라이언트는 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어 있어야함
- http 클라이언트는 post 요청같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해서 보내면 안됨.
: 에러가 발생하면 파이프라인을 통한 요청중에 어떤 것들이 서버에서 처리되었는지 클라이언트가 알길에 없기에 
-> 자동으로 
```

#### 커넥션 끊기
- TCP 커넥션은 양방향, 한쪽은 입력, 반대족은 입력

![](https://velog.velcdn.com/images/pigu/post/56c2883e-34f8-48f2-9cfe-24c82a0be3f8/image.png)


- close() : TCP 커넥션의 입력, 출력 채널 모두 끊기
- shutdown() : 한 채널(입력/출력 중 1택)만 개별적으로 끊기

- 예상치 못한 쓰기 에러를 예방하기 위해 절반 끊기 추천, 특히 출력 채널. 
	- 입력 채널을 끊으면 서버 운영체제에서 TCP 'connection reset by peer' 메시지를 클라이언트에게 보내는데, 대부분 운영체제에선느 이것을 심각한 에러로 취급해서 버퍼에 있는 데이터 모두 삭제함

- http 명세의 우아하게 커넥션 끊기 : 애플리케이션 자신의 출력 채널을 먼저 끊고 다른쪽에 있는 기기의 출력 채널이ㄱ 끊기는 것을 기다려야함. 그리고, 양쪽에서 더는 데이터를 전송하지 않을 것이라고 알려주면 커넥션은 리셋의 위험 없이 온전히 종료됨.
-> 하지만, 사앧방이 절반 끊기를 구현했다는 보장도 없고, 절반 끊기를 했는지 검사해준다는 보장도 없음. 그래서 절반끊기를 하고나서도 입력 채널에 대해 상태 검사를 주기적으로해서 데이터나 스트림의 끝을 식별해야함...




의문점 : 그럼 post 요청시에는 파이프라인을 통해 보내지않게끔 따로 설정해주어야하는가? 어떻게하는걸까..?
절반끊기는 또 어디서 구현하는걸까..
