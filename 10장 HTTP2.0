HTTP/1.1

- 구현의 단순성, 접근성을 두고 최적화
	- 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 메시지 교환 방식
- 성능의 문제
	- 응답을 받아야만 다음 요청 보낼 수 있음. (latency)
    - 병렬 커넥션/파이프라인 커넥션 도입. but 근본적인 해결책은 안됨 (4장)

- 이 문제를 해결하기위한 노력
	- WAKA 프로토콜
    - 마이크로소프트의 S+M 프로토콜
    - 구글의 SPDY 프로토콜 (헤더 압축, 하나의 TCP 커넥션에 여러 요청, 클라이언트 요청 없이 서버의 리소스 푸시 가능) -> HTTP/2.0의 기반이됨
    
    
    
스트림 도입 -> 하나의 커넥션 위에 여러 스트림, 동시처리, 
스트림 흐름 제어, 우선순위 부여
서버 푸쉬 (리소스 능동적으로 클라이언트에게 보낼 수 있음
호환성 -> HTTP/1.1과 요청/응답 메시지 의미 동ㅇ일하게 유지(문법만 변경)



## HTTP/2.0


### 프레임
![](https://velog.velcdn.com/images/pigu/post/5a5153da-339b-4419-b41b-f23180cbd6f2/image.png)


- 8바이트 헤더와 최대 16383바이트의 페이로드
- 종류 : 프레임의 종류. 프레임의 종류에 따라 페이로드의 형식/내용이 다름
- 길이 : 헤더를 뺀 페이로드의 길이 (14비트 무부호 정수)


### 스트림

- HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
- 한 쌍의 HTTP 요청과 응답
- 하나의 커넥션 위에서 여러 스트림 (여러 요청 동시 가능)
- 우선순위 존재(보장은 없음)
- 스트림 식별자
	- 클라이언트에 의해 초기화되면 홀수, 서버라면 짝수
    - 새로 만들어지는 식별자는 이전에 만들어진 것보다 커야함 (어길 시 PROTOCOL_ERROR로 응답)
- 협상 없는 스트림 생성 (생성을 위한 TCP 패킷 주고받는 시간 단축)
- 한 번 사용한 식별자는 재사용 불가
	- 식별자 고갈 시에는 커넥션 다시 맺음
- 스트림 블록 우려
	- WINDOW_UPDATE 프레임을 이용한 흐름 제어로 대처
    
### 헤더 압축

- 웹페이지를 하나 보기 위해 수십~수백 요청이 필요한 오늘날, 헤더의 크기는 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 줌
- HPACK 명세에 정의된 헤더 압축 방법으로 압축한 후, 헤더 블록 조각들로 쪼개져 전송. 받는 쪽에선는 이것들을 복원
- '압축 콘텍스트'를 HPACK에서 압축/해제 시에 사용
	- 항상 올바른 상태를 유지해야 함
    - 수신한 헤더의 압축을 풀면 그에 따라 변경됨.
    - 헤더를 쓰지않고 버리는 경우에도 압축 해제를 수행해야 함. 그럴수 없다면, COMPRESSION_ERROR와 함께 커넥션 끊어야 함
    
### 서버 푸시

- HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개 리소스 보낼 수 있게 해줌.
	- ex) HTML 문서 요청 받을 경우, HTML 문서가 링크하고 있는 이미지, CSS 파일, 자바스크립트 파일 등의 리소스를 클라이언트에게 푸시할 수 있음
	- 먼저 클라이언트에게 자원 푸시할 경우 PUSH_PROMISE 프레임을 전송해 미리 알려줘야함.
    	- RST_STREAM 프레임을 보내 거절 가능
- RST_STREAM
	- 서버가 푸시하려고 하는 자원을 클라이언트가 별도로 또 요청하게 되는 상황 피할 수 있음
    
- 서버 푸시 사용 시 주의점
	- 서버 푸시를 사용해도 중간의 프락시가 클라이언트에 리소스를 전달하지 않을 수 있고, 반대로 아무런 리소스를 받지 않아도 전달할 수 있음
    - 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않는 요청에 대해서만 푸시 가능
    - 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책(Same-origin policy)에 따라 검사해야함. ex) example.org로의 HTTP/2.0 커넥션은 www.example.org로부터의 푸시 응답을 허용하지 않음
   	- 서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH 0으로 설정할 것


### 알려진 보안 이슈

#### Intermediary Encapsulation Attacks(중개자 캡슐화 공격)

- HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환 시에 메시지 의미 변질 가능성
	- HTTP/2.0은 1.1과 달리 헤더 필드의 이름과 값을 바이너리로 인코딩
    - 정상적인 HTTP/2.0 요청/응답이 위조/불법적인 HTTP/1.1 메시지로 변역될 수 있음
    
(HTTP/1.1메시지를 HTTP/2.0 메시지로 변역하는 과정에서는 이런 문제 발생안함)

#### 긴 커넥션 유지로 인한 개인정보 노출 우려

- HTTP/2.0는 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두해 두기에 이와 같은 문제 가능성 존재
